intrinsic order(M::LMFDBRepCC) -> FldRatElt
  {Return order of the group}
  return (M`MagmaGrp)`order;
end intrinsic;

intrinsic indicator(M::LMFDBRepCC) -> FldRatElt
  {Computes the Frobenius-Schur indicator}
  Mat := M`MagmaGrp;
  ind := 0;
  for g in Mat do
    ind +:= Trace(g^2);
  end for;
  return (1/Get(M,'order'))*ind;
end intrinsic;

intrinsic cyc_order_mat(M::LMFDBRepCC) -> RngIntElt
  {an integer m so that the entries in the gens column lie in CyclotomicField(m)}
  MM := M`MagmaRep;
  MMmin := AbsoluteModuleOverMinimalField(MM);
  return Conductor(CoefficientRing(MMmin));
end intrinsic;

intrinsic schur_index(M::LMFDBRepCC) -> RngIntElt
  {Returns the ratio of the minimal degree of a number field containing all matrix entries by the degree of the number field generated by the traces}
  m := Get(M, "cyc_order_mat");
  n := Get(M, "cyc_order_traces");
  assert m mod n eq 0;
  return m div n;
end intrinsic;

intrinsic AbsoluteModuleOverMinimalField(~M::LMFDBRepCC)
  {Assign to M`MagmaRep the absolutely irreducible module M over the smallest possible field without increasing the dimension of the module. Also assign M`MagmaGrp to be the corresponding group.}
  MM := M`MagmaRep;
  MMmin := AbsoluteModuleOverMinimalField(MM);
  M`MagmaRep := MMmin;
  M`MagmaGrp := MatrixGroup(MMmin);
  print "Module over minimal field computed and assigned";
end intrinsic;

intrinsic WriteCyclotomicElement(u::FldCycElt) -> SeqEnum
  {Given an element u of a cyclotomic field with primitive root zeta_m, return a SeqEnum of pairs [c,e] such that
  u is the sum of c*zeta_m^e}
  K<z> := CyclotomicField(Conductor(Parent(u)) : Sparse := false);
  u_seq := Eltseq(K!u);
  cs := [];
  for i := 1 to #u_seq do
    if u_seq[i] ne 0 then
      Append(~cs, [u_seq[i], i-1]);
    end if;
  end for;
  return cs;
end intrinsic;

intrinsic ReadCyclotomicElement(cs::SeqEnum, m::RngIntElt) -> FldCycElt
  {Given a SeqEnum of pairs representing a cyclotomic field element as in the output of WriteCyclotomicElement, construct t    he corresponding cyclotomic field element.}
  K<z> := CyclotomicField(m : Sparse := false);
  u := K!0;
  for pair in cs do
    e := Integers()!pair[2];
    u +:= pair[1]*z^e;
  end for;
  return u, K;
end intrinsic;

intrinsic WriteCyclotomicMatrix(M::AlgMatElt) -> SeqEnum
  {Write a matrix over a cyclotomic field as a SeqEnum whose entries are of the form given by WriteCyclotomicElement}
  M_seq := [];
  for row in Rows(M) do
    Append(~M_seq, [WriteCyclotomicElement(el) : el in Eltseq(row)]);
  end for;
  return M_seq;
end intrinsic;

intrinsic ReadCyclotomicMatrix(cs::SeqEnum, m::RngIntElt) -> AlgMatElt
  {Given a SeqEnum as in the output of WriteCyclotomicMatrix, return the corresponding matrix}
  K<z> := CyclotomicField(m : Sparse := false);
  rows := [];
  for r in cs do
    Append(~rows, [ReadCyclotomicElement(el,m) : el in r]);
  end for;
  return Matrix(K,rows);
end intrinsic;
